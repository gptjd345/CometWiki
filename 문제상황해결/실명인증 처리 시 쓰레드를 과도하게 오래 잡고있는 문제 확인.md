
##### 연결문서
[[Blocking Method & Non Blocking Method]]

### 문제 확인
*  2023년 8월 4일과 10월 4일 엘리바이저에 특정 요청에 대해 쓰레드를 과도하게 오래잡고 있는 쓰레드가 굉장히 많이 발견되었다.
* 앨리바이저에서 찍어주는 쓰레드 덤프를 확인한 결과 내국인 실명인증 요청을 처리하는 과정에 문제가 있는 것을 확인하였다. 
* 해당 요청은 보통 길어도 건 당 10초 이내로 끝나는데 **191분**까지 잡고 있는 것을 쓰레드 덤프에서 확인하였다.
#문제발견

**에러 원인 파악 및 확인 과정**
현재 상황(2023.12.27 기준)
1. 현재 AP에서는 민원24의 실명확인 서비스를 사용하고 있고, 민원24 측에서 제공하는 샘플코드를 수정해서 사용하고 있다. 
2. ldap 객체를 생성하고 ldap.getData()메소드를 호출하도록 구성되어있는데 디컴파일러로 확인해본 결과 구현 내용이 native method 로 구현되어 있었다. 이에 대해 민원24측에 메소드 세부 구현내용이나, 네트워크 지연발생 시 해당 메소드에서 쓰레드를 과도하게 오래 잡을 여지가 있는지 문의 했으나 그런 것이 없다고 답변을 받았다. 
   * 문의/답변일 : 2023.12.22 (주민등록전산센터) 
3. 실명확인은 AP와 실명인증서버간의 통신 이후 결과값만 리턴하게 되어있어 별도의 DB 트랜잭션은 존재하지 않는다. 
4. AP단에서 실명인증서버로 요청 보내기전 Relay 해주는 모듈이 있고 이 해당 모듈과 통신할 때 URLConnection을 사용한다. 
가설
네트워크 지연에 의한 영향을 예상한 이유는 사건 발생 일을 제외한 나머지 날에는 위와 같은 문제가 발생하지 않았기 때문이다. 
URLConnetion은 ReadTimeout(데이터를 읽어들일 때 끊기는 경우 다음 데이터를 읽어들 때까지 기다리는 시간) 과 ConnectionTimeout (상대방과 연결에 성공할 때까지 걸리는 시간)을 설정할 수 있지만 connection을 통해 데이터를 주고받는 총 시간에 대한 제어는 불가능하다. 
따라서 ReadTimeout 에 의해 종료되지 않게 많은 양의 데이터를 천천히 전달하면 쓰레드가 오래 점유되도록 하여 문제 상황과 유사한 상황을 만들 수 있을 것이라 생각했다. 

가설 증명
데이터를 천천히 전달하는 httpserver 모듈을 만들기로 했다.

<h3>수신부</h3>
~~~java
public class SlowDataServer {
	public static void main(String[] args) throws Exception{
	//int port = findAvailablePort(); 사용가능한 임의의 포트를 받음
	/*
	 * 사설 포트 범위에서 하나 골라서 사용함.   
	 * netstat -tuln | grep 포트번호(tcp/udp 프로토콜을 사용하는 리스닝 상태의 포트조회) /         * sudo lsof -i : 포트번호 (사용중인 포트면 다 보여줌)
	 */
	int port = 55555; 
	HttpServer server = HttpServer.create(new InetSocketAddress(port),0);
	server.createContext(“/juminCheckTest.ajax”,new MyHandler());
	ExecutorService executor = Executors.newFixedThreadPool(5);
	server.setExecutor(executor);
	server.start();
	
	System.out.println(“server is running on port: “ + port);
	
	}

	static class Myhandler implements HttpHandler {
		@Override
		public void handle(HttpExchange t) throws IOException {
			String response = String.join(“”,Collections.nCopies(180,”This is the             response”));
			t.sendResponseHeader(200, response.length());
			System.out.println(“response length : “+response.length());
			OutputStream os = t.getResponseBody();
			for(char ch : response.toCharArray()) {
				os.write(ch);
				os.flush();
				try{
					//1초 쉬고 진행 
					Thread.sleep(1000);
				}
				catch(InterruptException e){
					Thread.currentThread().inturrupt();
					throw new IOException(e);
				}
			}
			os.close();
		
		}

	}

	private static int findAvailablePort() throws IOException {
		try(ServerSocket socket = new ServerSocket(0))
			return socket.getLocalPort();
	}

}


~~~

<h3>송신부(일부)</h3>
```java
url = new URL(“http://localhost:55555/juminCheckTest.ajax”);
urlconn = url.openConnection();
urlconn.setReadTimeout(30000);
urlconn.setConnectionTimeout(30000);
urlconn.DoOutput(true);

in new BufferedReader(new InputStreamReader(urlconn.getInputStream()));

String line;
while((line = in.readLine()) != null){
 LOGGER.info(“#### {} #####\n\n”,line);
}


```

테스트 방안 및 예상 결과 
실명인증 정상 처리시 전달하는 문자열의 길이가 3~4000바이트 정도 된다. 그만한 문자열을 생성하여 1글자 보낼 때마다 1초씩 기다리므로 180*18 = 3240 총 60분 소요될 것으로 예상된다. 실제 계속 스레드를 물고 있는 현상을 확인하였다. 
결과 : urlconnection 은 네트워크 지연으로 인해 데이터가 천천히 지속적으로 보내진다면 연결이 끝어지지 않는다. 즉, 해당 로직을 처리하는 쓰레드는 계속 반환되지 않고 점유된 상태 그대로 유지한다. 

해결 방안 
민원24측 말대로 gpki 라이브러리 관련 작업에서 네트워크 지연으로 인한 문제가 발생하지 않는다는 전제하에 실명인증을 처리하는 쓰레드를 별도로 생성하여 관리하고 전체 수행 가능 시간을 정해서 처리하도록 구성하기로 하였다.   AP <-> Relay <-> 실명인증서버  
Relay 서버는 통신시 tcp 소켓을 열어 통신한다. 
AP단에서 urlconnection 대신 최대 수행시간을 지정할 수 있는 httpClient를 사용하려면 Relay쪽 모듈(솔루션)도 수정이 불가피한 상황이다. 기존의 방식을 tcp 소켓통신 방식으로 바꿀 경우 AP단에서 처리가 가능하나 소스가 복잡해진다. 일단 행정안전부 주민과에 httpClient로 통신하도록 하는 가이드가 존재 여부를 확인하는 요청 보냈다.
행정안전부 주민과에서는 ldap쪽에 연락해보라고 하고 urlconnection으로 연결하는 것에 대한 문제도 뭔 말인지 모르는거 같고 맘에 안들면 사용하는 기관에서 수정해서 쓰라고 했다. 
* 문의/답변일 : 2023.12.22 (주민등록전산센터) 




	@Async 어노테이션을 사용하는 경우
	스프링에서 내부적으로 TaskExecutor 인터페이스를 사용한다. 
	이 인터페이스의 구현체 중 하나인 ThreadPoolTaskExecutor는 쓰레드 풀을 사용하여 비동기 작업을 처리한다. 
	별도의 쓰레드를 직접관리하는 대신 @Async어노테이션과 ThreadPoolTaskExecutor라는 구현체를 사용하여 비동기 처리를 구현하는 것이 권장된다. 
	직접 관리할 필요가 없으므로 코드가 간결해지고 쓰레드 풀을 이용한 효율적인 리소스관리가 가능하다? 
```java
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

 @Override
 public Executor getAsyncExecutor() {
 
 }

 @Override
 public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
 
 }

}


```